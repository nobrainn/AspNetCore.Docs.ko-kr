---
title: ASP.NET Core 2.2에서 3.0로 마이그레이션
author: rick-anderson
description: ASP.NET Core 2.2 프로젝트를 ASP.NET Core 3.0로 마이그레이션하는 방법에 대해 알아봅니다.
ms.author: riande
ms.custom: mvc
ms.date: 05/03/2020
no-loc:
- Blazor
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 228607cf0156e142afa441cfc861a1f19f512514
ms.sourcegitcommit: cd73744bd75fdefb31d25ab906df237f07ee7a0a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/05/2020
ms.locfileid: "84452007"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>ASP.NET Core 2.2에서 3.0로 마이그레이션

[Scott Addie](https://github.com/scottaddie) 및 [Rick Anderson](https://twitter.com/RickAndMSFT)

이 문서에서는 기존 ASP.NET Core 2.2 프로젝트를 ASP.NET Core 3.0로 업데이트 하는 방법을 설명 합니다. 다음에 새 ASP.NET Core 3.0 프로젝트를 만드는 것이 유용할 수 있습니다.

* ASP.NET Core 2.2 코드와 비교 합니다.
* 관련 변경 내용을 ASP.NET Core 3.0 프로젝트에 복사 합니다.

## <a name="prerequisites"></a>사전 요구 사항

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Mac용 Visual Studio](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>global.json의 .NET Core SDK 버전 업데이트

솔루션이 특정 .NET Core SDK 버전을 대상으로 하는 [전역 json](/dotnet/core/tools/global-json) 파일에 의존 하는 경우 해당 `version` 속성을 컴퓨터에 설치 된 3.0 버전으로 업데이트 합니다.

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>프로젝트 파일 업데이트

### <a name="update-the-target-framework"></a>대상 프레임 워크 업데이트

ASP.NET Core 3.0 이상 .NET Core 에서만 실행 됩니다. [대상 프레임 워크 모니커 (TFM)](/dotnet/standard/frameworks) 를 `netcoreapp3.0` 다음과 같이 설정 합니다.

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>사용 되지 않는 패키지 참조 제거

ASP.NET Core 3.0에 대해 많은 수의 NuGet 패키지가 생성 되지 않습니다. 이러한 패키지 참조는 프로젝트 파일에서 제거 해야 합니다. ASP.NET Core 2.2 웹 앱에 대 한 다음 프로젝트 파일을 고려 합니다.

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

ASP.NET Core 3.0에 대 한 업데이트 된 프로젝트 파일:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

업데이트 된 ASP.NET Core 3.0 프로젝트 파일:

* `<PropertyGroup>`에서
  * TFM를로 업데이트 합니다.`netcoreapp3.0`
  * 요소를 제거 `<AspNetCoreHostingModel>` 합니다. 자세한 내용은이 문서의 [in-process 호스팅 모델](#in-process-hosting-model) 을 참조 하세요.

* `<ItemGroup>`에서
  * `Microsoft.AspNetCore.App`제거 됩니다. 자세한 내용은이 문서의 [프레임 워크 참조](#framework-reference) 를 참조 하세요.
  * `Microsoft.AspNetCore.Razor.Design`가 제거 되 고 다음 패키지 목록에서 더 이상 생성 되지 않습니다.

더 이상 생성 되지 않는 패키지의 전체 목록을 보려면 다음 확장 목록을 선택 합니다.

<details>
    <summary>더 이상 생성 되지 않는 패키지 목록을 확장 하려면 클릭 하십시오.</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>AspNetCore.Razor</li>
        <li>AspNetCore Razor . Microsoft.aspnetcore.mvc.razor.viewcompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>AspNetCore.Razor</li>
        <li>AspNetCore Razor . 런타임에서</li>
        <li>AspNetCore Razor . 디자인과</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>AspNetCore.SignalR</li>
        <li>AspNetCore SignalR . Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>주요 변경 내용 검토

[주요 변경 내용 검토](#break)

### <a name="framework-reference"></a>프레임 워크 참조

위에 나열 된 패키지 중 하나를 통해 사용할 수 있는 ASP.NET Core 기능은 공유 프레임 워크의 일부로 제공 됩니다 `Microsoft.AspNetCore.App` . *공유 프레임워크*는 머신에 설치된 어셈블리(*.dll* 파일) 세트이며 런타임 구성 요소 및 타기팅 팩을 포함합니다. 자세한 내용은 [공유 프레임워크](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/)를 참조하세요.

* `Microsoft.NET.Sdk.Web` SDK를 대상으로 하는 프로젝트는 `Microsoft.AspNetCore.App` 프레임워크를 암시적으로 참조합니다.

  이러한 프로젝트에는 추가 참조가 필요하지 않습니다.

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* 또는 SDK를 대상으로 하는 프로젝트는 `Microsoft.NET.Sdk` `Microsoft.NET.Sdk.Razor` 명시적 `FrameworkReference` 를에 추가 해야 합니다 `Microsoft.AspNetCore.App` .

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Docker를 사용 하는 프레임 워크 종속 빌드

ASP.NET Core [공유 프레임 워크](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) 에 종속 된 패키지를 사용 하는 콘솔 앱의 프레임 워크 종속 빌드는 다음과 같은 런타임 오류를 제공할 수 있습니다.

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`는 ASP.NET Core 런타임을 포함 하는 공유 프레임 워크로 [dotnet/Core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker 이미지에만 존재 합니다. 3.0 SDK는 공유 프레임 워크에서 사용할 수 있는 라이브러리의 중복 복사본을 포함 하지 않아 ASP.NET Core를 사용 하 여 프레임 워크 종속 빌드의 크기를 줄입니다. 이는 최대 18mb까지 절감 될 수 있지만 앱을 실행 하려면 ASP.NET Core 런타임이 제공/설치 되어 있어야 합니다.

앱에 ASP.NET Core 공유 프레임 워크에 대 한 종속성 (직접 또는 간접)이 있는지 확인 하려면 앱 빌드/게시 중에 생성 된 *runtimeconfig.template.json* 파일을 검사 합니다. 다음 JSON 파일은 ASP.NET Core 공유 프레임 워크에 대 한 종속성을 보여 줍니다.

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

앱에서 Docker를 사용 하는 경우 ASP.NET Core 3.0를 포함 하는 기본 이미지를 사용 합니다. 예들 들어 `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`입니다.

### <a name="add-package-references-for-removed-assemblies"></a>제거 되는 어셈블리에 대 한 패키지 참조 추가

ASP.NET Core 3.0는 이전에 패키지 참조의 일부인 일부 어셈블리를 제거 `Microsoft.AspNetCore.App` 합니다. 제거 된 어셈블리를 시각화 하려면 두 개의 공유 프레임 워크 폴더를 비교 합니다. 예를 들어 2.2.7 및 3.0.0 버전을 비교 합니다.

![공유 프레임 워크 어셈블리 비교](22-to-30/_static/assembly-diff.png)

제거 된 어셈블리에서 제공 하는 기능을 계속 사용 하려면 해당 패키지의 3.0 버전을 참조 하세요.

* **개별 사용자 계정을** 포함 하는 템플릿 생성 웹 앱에는 다음 패키지를 추가 해야 합니다.

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  데이터베이스 공급자 관련 패키지를 참조 하는 방법에 대 한 자세한 내용은 [데이터베이스 공급자](/ef/core/providers/index)를 참조 하세요.

* Identity UI

  AspNetCore를 참조 하 여 [ Identity UI](xref:security/authentication/identity) 에 대 한 지원을 추가할 수 있습니다. [ Identity UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) 패키지.

* SPA 서비스

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* 인증: 타사 인증 흐름에 대 한 지원은 NuGet 패키지로 제공 됩니다.

  * Facebook OAuth ([AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Microsoft 계정 인증 ([AspNetCore. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Openid connect Connect 인증 ([AspNetCore connect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Openid connect Connect 전달자 토큰 ([AspNetCore. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * WsFederation 인증 ([AspNetCore WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* 에 대 한 형식 지정 및 콘텐츠 협상 지원 `System.Net.HttpClient` : [WebApi](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet 패키지는 `System.Net.HttpClient` 및와 같은 api를 사용 하 여에 유용한 확장성을 제공 `ReadAsAsync` `PostJsonAsync` 합니다.

* Razor런타임 컴파일: 뷰 및 페이지의 런타임 컴파일 지원은 Razor 이제 AspNetCore의 일부입니다 [ Razor . RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC `Newtonsoft.Json` (Json.NET) 지원:에서 mvc 사용에 대 한 지원은 `Newtonsoft.Json` 이제의 일부입니다 [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="startup-changes"></a>시작 변경

다음 이미지는 ASP.NET Core 2.2 페이지 웹 앱에서 삭제 된 줄과 변경 된 줄을 보여 줍니다 Razor .

![ASP.NET Core 2.2 웹 앱에서 삭제 되 고 변경 된 줄 Razor](22-to-30/_static/startup2.2.png)

위의 그림에서 삭제 된 코드는 빨강으로 표시 됩니다. 삭제 된 코드는 파일을 비교 하기 전에 삭제 된 쿠키 옵션 코드를 표시 하지 않습니다.

다음 이미지는 ASP.NET Core 3.0 페이지 웹 앱에서 추가 및 변경 된 줄을 보여 줍니다 Razor .

![ASP.NET Core 3.0 웹 앱에서 추가 및 변경 된 줄 Razor](22-to-30/_static/startup3.0.png)

위의 그림에서 추가 된 코드는 녹색으로 표시 됩니다. 다음 변경 내용에 대 한 정보:

* `services.AddMvc`에 대 `services.AddRazorPages` 한 자세한 내용은이 문서의 [MVC 서비스 등록](#mvc-service-registration) 을 참조 하세요.
* `CompatibilityVersion`을 참조 하십시오 <xref:mvc/compatibility-version> .
* `IHostingEnvironment`에 대 `IWebHostEnvironment` 한 자세한 내용은 [이 GitHub 공지](https://github.com/dotnet/AspNetCore/issues/7749)를 참조 하세요.
* `app.UseAuthorization`권한 부여 미들웨어를 추가 해야 하는 순서를 보여 주기 위해 템플릿에 추가 되었습니다. 앱에서 권한 부여를 사용 하지 않는 경우에 대 한 호출을 안전 하 게 제거할 수 있습니다 `app.UseAuthorization` .
* `app.UseEndpoints`이 문서의 [ Razor 페이지](#razor-pages) 또는 [마이그레이션 시작. 구성](#migrate-startupconfigure) 을 참조 하세요.

### <a name="analyzer-support"></a>분석기 지원

`Microsoft.NET.Sdk.Web` [AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) 패키지의 일부로 이전에 제공 된 분석기를 암시적으로 참조 하는 프로젝트입니다. 이러한 기능을 사용 하도록 설정 하는 데 필요한 추가 참조는 없습니다.

앱이 이전에 [AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) 패키지를 사용 하 여 제공한 [API 분석기](xref:web-api/advanced/analyzers) 를 사용 하는 경우 .net Core 웹 SDK의 일부로 제공 되는 분석기를 참조 하도록 프로젝트 파일을 편집 합니다.

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Razor클래스 라이브러리

RazorMVC에 대 한 UI 구성 요소를 제공 하는 클래스 라이브러리 프로젝트는 `AddRazorSupportForMvc` 프로젝트 파일에서 속성을 설정 해야 합니다.

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>In-Process 호스팅 모델

프로젝트는 ASP.NET Core 3.0 이상에서 [in-process 호스팅 모델로](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) 기본 됩니다. `<AspNetCoreHostingModel>`해당 값이 인 경우 프로젝트 파일에서 속성을 선택적으로 제거할 수 있습니다 `InProcess` .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>구성

(Program.cs)에서 제공 하는 [웹 호스트 작성기](#hostb) 로 Kestrel 구성 마이그레이션 `ConfigureWebHostDefaults` :*Program.cs*

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

앱이를 사용 하 여 호스트를 수동으로 만드는 경우 `HostBuilder` `UseKestrel` 의 웹 호스트 빌더에서를 호출 합니다 `ConfigureWebHostDefaults` .

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>연결의 미들웨어가 연결 어댑터를 대체 합니다.

연결 어댑터 ( `Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter` )가 Kestrel에서 제거 되었습니다. 연결 어댑터를 연결 미들웨어로 대체 합니다. 연결 미들웨어는 ASP.NET Core 파이프라인의 HTTP 미들웨어와 유사 하지만 하위 수준 연결의 경우입니다. HTTPS 및 연결 로깅:

* 연결 어댑터에서 연결 미들웨어로 이동 되었습니다.
* 이러한 확장 메서드는 이전 버전의 ASP.NET Core와 동일 하 게 작동 합니다. 

자세한 내용은 [Kestrel 문서의 ListenOptions 섹션에서 TlsFilterConnectionHandler 예](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols)를 참조 하세요.

### <a name="transport-abstractions-moved-and-made-public"></a>전송 추상화 이동 및 공개

Kestrel 전송 계층이 `Connections.Abstractions`에서 공용 인터페이스로 공개되었습니다. 이러한 업데이트의 일부로:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`및 관련 형식이 제거 되었습니다.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay><xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>는에서 전송 옵션으로 이동 되었습니다.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`가에서 제거 되었습니다 <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions> .

자세한 내용은 다음 GitHub 리소스를 참조 하세요.

* [클라이언트/서버 네트워킹 추상화 (dotnet/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [새 bedrock 수신기 추상화를 구현 하 고 맨 위에 cross-plat Kestrel을 구현 합니다 (dotnet/AspNetCore #10321).](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel 요청 트레일러 헤더

이전 버전의 ASP.NET Core를 대상으로 하는 앱의 경우:

* Kestrel은 HTTP/1.1 청크 분할 트레일러 헤더를 요청 헤더 컬렉션에 추가 합니다.
* 트레일러는 요청 본문을 끝으로 읽은 후에 사용할 수 있습니다.

이로 인해 헤더와 트레일러의 모호성에 대 한 우려 사항이 발생 하므로, 3.0에서 트레일러는 새 컬렉션 ()으로 이동 되었습니다 `RequestTrailerExtensions` .

HTTP/2 요청 트레일러는 다음과 같습니다.

* ASP.NET Core 2.2에서는 사용할 수 없습니다.
* 3.0에서로 사용할 수 있습니다 `RequestTrailerExtensions` .

이러한 트레일러에 액세스 하기 위한 새 요청 확장 메서드가 있습니다. HTTP/1.1과 마찬가지로 트레일러는 요청 본문을 끝까지 읽은 후에 사용할 수 있습니다.

3.0 릴리스의 경우 다음 `RequestTrailerExtensions` 메서드를 사용할 수 있습니다.

* `GetDeclaredTrailers`: `Trailer` 본문 후에 사용할 트레일러를 나열 하는 요청 헤더를 가져옵니다.
* `SupportsTrailers`: 요청에서 트레일러 헤더 수신을 지원 하는지 여부를 나타냅니다.
* `CheckTrailersAvailable`: 요청에서 트레일러를 지원 하 고 읽을 수 있는지 여부를 확인 합니다. 이 검사는 읽을 후행이 있다고 가정 하지 않습니다. 이 메서드에서을 반환 하더라도 읽을 트레일러가 없을 수 있습니다 `true` .
* `GetTrailer`: 응답에서 요청 된 후행 헤더를 가져옵니다. `SupportsTrailers`를 호출 하기 전에 확인 `GetTrailer` 하거나 <xref:System.NotSupportedException> 요청이 후행 헤더를 지원 하지 않는 경우이 발생할 수 있습니다.

자세한 내용은 [별도의 컬렉션에 요청 트레일러 배치 (dotnet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410)를 참조 하세요.

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO 사용 안 함

`AllowSynchronousIO`,, 등의 동기 i/o Api를 사용 하거나 사용 하지 않도록 설정 `HttpRequest.Body.Read` `HttpResponse.Body.Write` `Stream.Flush` 합니다. 이러한 Api는 앱 작동 중단에 대 한 스레드 고갈의 소스입니다. 3\.0에서 `AllowSynchronousIO`는 기본적으로 사용하지 않도록 설정됩니다. 자세한 내용은 [Kestrel 문서의 동기 i/o 섹션](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io)을 참조 하세요.

동기 i/o가 필요한 경우에는 사용 중인 서버에서 옵션을 구성 하 여 사용할 수 있습니다 `AllowSynchronousIO` ( `ConfigureKestrel` 예: Kestrel을 사용 하는 경우). 서버 (Kestrel, HttpSys, TestServer 등)에는 `AllowSynchronousIO` 다른 서버에 영향을 주지 않는 자체 옵션이 있습니다. 다음 옵션을 사용 하 여 요청 별로 모든 서버에 대해 동기 i/o를 사용 하도록 설정할 수 있습니다 `IHttpBodyControlFeature.AllowSynchronousIO` .

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

<xref:System.IO.TextWriter> [Dispose](/dotnet/standard/garbage-collection/implementing-dispose)에서 동기 api를 호출 하는 다른 스트림이나 구현에 문제가 있는 경우 대신 새 API를 호출 <xref:System.IO.Stream.DisposeAsync*> 합니다.

자세한 내용은 [[알림] AllowSynchronousIO disabled in all servers (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644)를 참조 하세요.

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>AspNetCore 어셈블리를 제거 했습니다.

ASP.NET Core 2.1에서는 *AspNetCore* 의 내용이 *AspNetCore*로 이동 되었습니다... n a m .dll.. n a m .dll. 이는 특성을 사용 하는 주요 업데이트가 아닙니다 `TypeForwardedTo` . 3.0의 경우 빈 *AspNetCore* 어셈블리 및 NuGet 패키지는 제거 되었습니다 (예를 들어,

[AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) 를 참조 하는 라이브러리는 ASP.NET Core 종속성을 2.1 이상으로 업데이트 해야 합니다.

ASP.NET Core 2.1 이상을 대상으로 하는 앱 및 라이브러리는 [AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) 패키지에 대 한 직접 참조를 모두 제거 해야 합니다.

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Newtonsoft.json (Json.NET) 지원

[ASP.NET Core 공유 프레임 워크를 개선](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)하는 작업의 일부로 [Json.NET (newtonsoft.json)](https://www.newtonsoft.com/json/help/html/Introduction.htm) 가 ASP.NET Core 공유 프레임 워크에서 제거 되었습니다.

ASP.NET Core에 대 한 기본 JSON serializer는 <xref:System.Text.Json> .Net Core 3.0의 새로운 버전입니다. 가능 하면를 사용 하는 것이 좋습니다 `System.Text.Json` . 고성능 이며 추가 라이브러리 종속성이 필요 하지 않습니다. 그러나가 새로운 이기 때문에 `System.Text.Json` 현재 앱에 필요한 기능이 없을 수 있습니다. 자세한 내용은 [newtonsoft.json에서 system.string으로 마이그레이션하는 방법](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)을 참조 하세요.

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-signalr-project"></a>ASP.NET Core 3.0 프로젝트에서 Newtonsoft.json 사용 SignalR

* AspNetCore를 설치 합니다. [ SignalR NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet 패키지.

* 클라이언트에서 `AddNewtonsoftJsonProtocol` 메서드 호출을 인스턴스에 연결 합니다 `HubConnectionBuilder` .

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* 서버에서 `AddNewtonsoftJsonProtocol` 메서드 호출을의 메서드 호출에 연결 합니다 `AddSignalR` `Startup.ConfigureServices` .

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>ASP.NET Core 3.0 MVC 프로젝트에서 Newtonsoft.json 사용

* 패키지를 설치 [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) 합니다.

* `Startup.ConfigureServices`를 호출 하도록 업데이트 `AddNewtonsoftJson` 합니다.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`는 새로운 MVC 서비스 등록 방법과 호환 됩니다.

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`설정은 다음에 대 한 호출에서 설정할 수 있습니다 `AddNewtonsoftJson` .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**참고:** 메서드를 `AddNewtonsoftJson` 사용할 수 없는 경우 패키지를 설치 했는지 확인 [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) 합니다. 일반적인 오류는 패키지 대신 [newtonsoft.json](https://www.nuget.org/packages/Newtonsoft.Json/) 패키지를 설치 하는 것입니다. [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)

## <a name="mvc-service-registration"></a>MVC 서비스 등록

ASP.NET Core 3.0에는 내에서 MVC 시나리오를 등록 하기 위한 새로운 옵션이 추가 `Startup.ConfigureServices` 되었습니다.

에서 MVC 시나리오와 관련 된 세 가지 새로운 최상위 확장 메서드를 `IServiceCollection` 사용할 수 있습니다. 템플릿은 대신 이러한 새 메서드를 사용 `AddMvc` 합니다. 그러나는 `AddMvc` 이전 릴리스에서와 같이 계속 동작 합니다.

다음 예에서는 뷰 또는 페이지가 아니라 컨트롤러 및 API 관련 기능에 대 한 지원을 추가 합니다. API 템플릿에서는 다음 코드를 사용 합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

다음 예에서는 컨트롤러, API 관련 기능 및 보기에 대 한 지원을 추가 하지만 페이지는 추가 하지 않습니다. 웹 응용 프로그램 (MVC) 템플릿은 다음 코드를 사용 합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

다음 예에서는 Razor 페이지 및 최소 컨트롤러 지원에 대 한 지원을 추가 합니다. 웹 응용 프로그램 템플릿은 다음 코드를 사용 합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

새 메서드를 결합할 수도 있습니다. 다음 예제는 ASP.NET Core 2.2에서를 호출 하는 것과 같습니다 `AddMvc` .

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>시작 코드 라우팅

앱이 또는를 호출 하는 경우 `UseMvc` `UseSignalR` 가능 하면 앱을 [끝점 라우팅](xref:fundamentals/routing) 으로 마이그레이션합니다. 이전 버전의 MVC와의 끝점 라우팅 호환성을 개선 하기 위해 ASP.NET Core 2.2에서 도입 된 URL 생성의 일부 변경 내용을 되돌렸습니다. 2.2에서 끝점 라우팅을 사용 하는 데 문제가 발생 한 경우 다음과 같은 예외를 제외 하 고 ASP.NET Core 3.0에서 향상 된 기능을 사용할 수 있습니다.

* 앱이에서 구현 `IRouter` 하거나 상속 하는 경우 `Route` [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) 을 대체로 사용 합니다.
* 앱 `RouteData.Routers` 이 MVC 내에서 직접 액세스 하 여 url을 구문 분석 하는 경우 [ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*)를 사용 하 여 바꿀 수 있습니다. 
  * 경로 이름을 사용 하 여 경로를 정의 합니다.
  * `LinkParser.ParsePathByEndpointName`을 사용 하 고 원하는 경로 이름을 전달 합니다.

끝점 라우팅은와 동일한 경로 패턴 구문 및 경로 패턴 작성 기능을 지원 합니다 `IRouter` . 끝점 라우팅은 `IRouteConstraint` 를 지원 합니다. 끝점 라우팅은 `[Route]` , `[HttpGet]` 및 기타 MVC 라우팅 특성을 지원 합니다.

대부분의 응용 프로그램의 경우에는 `Startup` 변경만 필요 합니다.

### <a name="migrate-startupconfigure"></a>마이그레이션 시작. 구성

일반 권장 사항:

* `UseRouting`를 추가합니다.
* 앱이를 호출 하는 경우 `UseStaticFiles` 앞에 놓습니다 `UseStaticFiles` **before** `UseRouting` .
* 앱에서 또는와 같은 인증/권한 부여 기능을 사용 하는 경우, 및에 대 한 호출을 수행 `AuthorizePage` `[Authorize]` 합니다 `UseAuthentication` `UseAuthorization` **after** `UseRouting` `UseCors` `UseEndpoints` .

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* `UseMvc`또는 `UseSignalR` 를로 바꿉니다 `UseEndpoints` .
* 앱에서와 같은 [cors](xref:security/cors) 시나리오를 사용 하는 경우 `[EnableCors]` cors를 사용 하는 다른 미들웨어 앞에에 대 한 호출을 추가 `UseCors` 합니다 (예: `UseCors` , 및 앞에 두기 `UseAuthentication` `UseAuthorization` `UseEndpoints` ).
* `IHostingEnvironment`로 대체 `IWebHostEnvironment` 하 고 `using` 네임 스페이스에 대 한 문을 추가 <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> 합니다.
* `IApplicationLifetime` <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> 네임 스페이스)로 대체 합니다.
* `EnvironmentName` <xref:Microsoft.Extensions.Hosting.Environments> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> 네임 스페이스)로 대체 합니다.

다음 코드는 `Startup.Configure` 일반적인 ASP.NET Core 2.2 앱의 예제입니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

이전 코드를 업데이트 한 후 `Startup.Configure` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> 대부분의 앱에서, 및에 대 한 호출은 및에 대 한 호출과 `UseAuthentication` `UseAuthorization` `UseCors` 적용 사이에 나타나야 합니다 `UseRouting` `UseEndpoints` .

### <a name="health-checks"></a>상태 검사

상태 검사는 제네릭 호스트와의 엔드포인트 라우팅을 사용합니다. `Startup.Configure`에서 엔드포인트 URL 또는 상대 경로를 사용하여 엔드포인트 작성기에 `MapHealthChecks`를 호출합니다.

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

상태 검사 엔드포인트는 다음을 수행할 수 있습니다.

* 허용되는 호스트/포트를 하나 이상 지정합니다.
* 권한 부여가 필요합니다.
* CORS가 필요합니다.

자세한 내용은 <xref:host-and-deploy/health-checks>를 참조하세요.

### <a name="security-middleware-guidance"></a>보안 미들웨어 지침

권한 부여 및 CORS에 대 한 지원은 [미들웨어](xref:fundamentals/middleware/index) 접근 방식에 통합 됩니다. 이를 통해 이러한 시나리오에서 동일한 미들웨어 및 기능을 사용할 수 있습니다. 업데이트 된 권한 부여 미들웨어는이 릴리스에서 제공 되며, CORS 미들웨어는 MVC 컨트롤러에서 사용 하는 특성을 이해할 수 있도록 향상 되었습니다.

#### <a name="cors"></a>CORS

이전에 CORS는 구성 하기가 어려울 수 있습니다. 미들웨어는 일부 사용 사례에서 사용할 수 있도록 제공 되었지만 다른 사용 사례에서 미들웨어 **없이** 사용 하기 위한 MVC 필터입니다. ASP.NET Core 3.0를 사용 하는 경우 CORS가 필요한 모든 앱은 끝점 라우팅과 함께 CORS 미들웨어를 사용 하는 것이 좋습니다. `UseCors`기본 정책으로 제공할 수 있으며, `[EnableCors]` 및 특성을 `[DisableCors]` 사용 하 여 필요한 경우 기본 정책을 재정의할 수 있습니다.

다음 예제에서는

* CORS는 명명 된 정책을 사용 하는 모든 끝점에 대해 사용 하도록 설정 됩니다 `default` .
* `MyController`클래스는 특성을 사용 하 여 CORS를 사용 하지 않도록 설정 합니다 `[DisableCors]` .

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>권한 부여

이전 버전의 ASP.NET Core에서는 특성을 통해 권한 부여 지원을 제공 했습니다 `[Authorize]` . 권한 부여 미들웨어를 사용할 수 없습니다. ASP.NET Core 3.0에서는 권한 부여 미들웨어가 필요 합니다. ASP.NET Core 권한 부여 미들웨어 ( `UseAuthorization` )는 바로 뒤에 배치 하는 것이 좋습니다 `UseAuthentication` . 권한 부여 미들웨어는 재정의 될 수 있는 기본 정책으로 구성 될 수도 있습니다.

ASP.NET Core 3.0 이상에서는 `UseAuthorization` 가에서 호출 되 `Startup.Configure` 고 다음에 `HomeController` 로그인 한 사용자가 필요 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

끝점 라우팅을 사용 하는 경우를 구성 `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` 하는 대신 권한 부여 미들웨어에 의존 하는 것이 좋습니다.  앱이 MVC에서을 전역 필터로 사용 하는 경우 `AuthorizeFilter` 에 대 한 호출에서 정책을 제공 하도록 코드를 리팩터링 하는 것이 좋습니다 `AddAuthorization` .

는 `DefaultPolicy` 처음에 인증을 요구 하도록 구성 되므로 추가 구성이 필요 하지 않습니다. 다음 예제에서 MVC 끝점은로 표시 `RequireAuthorization` 되므로 모든 요청은에 따라 권한을 부여 받아야 합니다 `DefaultPolicy` . 그러나에서는 `HomeController` 사용자가 응용 프로그램에 로그인 할 필요 없이 다음과 같은 이유로 액세스할 수 있습니다 `[AllowAnonymous]` .

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>특정 끝점에 대 한 권한 부여

특정 끝점 클래스에 대해 권한 부여를 구성할 수도 있습니다. 다음 코드는 전역을 구성 하는 MVC 앱 `AuthorizeFilter` 을 권한 부여가 필요한 특정 정책을 사용 하는 앱으로 변환 하는 예제입니다.

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

정책을 사용자 지정할 수도 있습니다. 는 `DefaultPolicy` 인증을 요구 하도록 구성 되어 있습니다.

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

`[Authorize]`또는 `RequireAuthorization` 를 구성 하거나를 구성 하 여 모든 끝점에서 권한 부여를 요구 하도록 구성할 수 있습니다 `FallbackPolicy` . 는와 `FallbackPolicy` 다릅니다 `DefaultPolicy` . 는 `DefaultPolicy` 또는에서 트리거되고 `[Authorize]` `RequireAuthorization` `FallbackPolicy` 다른 정책이 설정 되지 않은 경우는 트리거됩니다. `FallbackPolicy`는 처음에 권한 부여 없이 요청을 허용 하도록 구성 됩니다.

다음 예제는 이전 예제와 동일 `DefaultPolicy` 하지만 `FallbackPolicy` 가 지정 된 경우를 제외 하 고를 사용 하 여 항상 모든 끝점에 대 한 인증을 요구 합니다 `[AllowAnonymous]` .

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

미들웨어 별 권한 부여는 권한 부여에 대 한 특정 지식이 없는 프레임 워크 없이 작동 합니다. 예를 들어 [상태 검사](xref:host-and-deploy/health-checks) 에는 권한 부여에 대 한 특정 지식이 없지만 상태 검사에는 미들웨어에서 적용 되는 구성 가능한 권한 부여 정책이 있을 수 있습니다.

또한 각 끝점은 권한 부여 요구 사항을 사용자 지정할 수 있습니다. 다음 예제에서는를 `UseAuthorization` 사용 하 여 권한 부여를 처리 `DefaultPolicy` 하지만 `/healthz` 상태 검사 끝점에는 사용자가 필요 합니다 `admin` .

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

보호는 일부 시나리오에 대해 구현 됩니다. 누락 된 미들웨어로 인해 권한 부여 또는 CORS 정책을 건너뛰면 끝점 미들웨어는 예외를 throw 합니다. 구성 오류에 대 한 추가 피드백을 제공 하는 분석기 지원이 진행 중입니다.

#### <a name="custom-authorization-handlers"></a>사용자 지정 권한 부여 처리기

앱에서 사용자 지정 [권한 부여 처리기](xref:security/authorization/policies#authorization-handlers)를 사용 하는 경우 끝점 라우팅은 다른 리소스 형식을 MVC가 아닌 처리기에 전달 합니다. 권한 부여 처리기 컨텍스트 리소스를 형식 <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> ( [MVC 필터로 제공](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)된 리소스 형식)으로 간주 하는 처리기는 형식의 리소스 <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (끝점 라우팅을 통해 권한 부여 처리기에 지정 된 리소스 형식)를 처리 하도록 업데이트 해야 합니다.

MVC는 여전히 `AuthorizationFilterContext` 리소스를 사용 하므로 앱에서 끝점 라우팅 권한 부여와 함께 MVC 권한 부여 필터를 사용 하는 경우 두 가지 유형의 리소스를 모두 처리 해야 할 수 있습니다.

### SignalR

허브 매핑은 SignalR 이제 내에서 수행 `UseEndpoints` 됩니다.

각 허브를에 매핑합니다 `MapHub` . 이전 버전과 마찬가지로 각 허브는 명시적으로 나열 됩니다.

다음 예제에서는 허브에 대 한 지원이 `ChatHub` SignalR 추가 되었습니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

클라이언트에서 메시지 크기 제한을 제어 하는 새로운 옵션이 있습니다. 예를 들어 `Startup.ConfigureServices`에서는 다음과 같습니다.

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

ASP.NET Core 2.2에서를 설정 하 여 `TransportMaxBufferSize` 최대 메시지 크기를 효과적으로 제어할 수 있습니다. ASP.NET Core 3.0에서이 옵션은 이제는 백 압력이 관찰 되기 전의 최대 크기만 제어 합니다.

### <a name="mvc-controllers"></a>MVC 컨트롤러

이제 컨트롤러 매핑이 내에서 발생 `UseEndpoints` 합니다.

`MapControllers`앱에서 특성 라우팅을 사용 하는 경우를 추가 합니다. 라우팅은 ASP.NET Core 3.0 이상에서 많은 프레임 워크에 대 한 지원을 포함 하기 때문에 특성으로 라우팅된 컨트롤러를 추가 하는 것은 옵트인 (opt in)입니다.

다음 내용을

* `MapRoute`(`MapControllerRoute` 사용)
* `MapAreaRoute`(`MapAreaControllerRoute` 사용)

라우팅은 이제 MVC 이상에 대 한 지원을 포함 하므로 이러한 메서드가 수행 하는 작업을 명확 하 게 나타내도록 용어가 변경 되었습니다. 와 같은 기존 경로 `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` 는 추가 된 순서 대로 적용 됩니다. 먼저 특정 경로 (예: 영역에 대 한 경로)를 추가 합니다.

다음 예제에서는

* `MapControllers`특성 라우트된 컨트롤러에 대 한 지원을 추가 합니다.
* `MapAreaControllerRoute`영역에 있는 컨트롤러에 대 한 기본 경로를 추가 합니다.
* `MapControllerRoute`컨트롤러에 대 한 기본 경로를 추가 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>컨트롤러 작업 이름에서 비동기 접미사 제거

ASP.NET Core 3.0에서 ASP.NET Core MVC는 `Async` 컨트롤러 작업 이름에서 접미사를 제거 합니다. 라우팅 및 링크 생성은 모두이 새 기본값의 영향을 받습니다. 다음은 그 예입니다.

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

ASP.NET Core 3.0 이전:

* 이전 작업은 *Products/ListAsync* 경로에서 액세스할 수 있습니다.
* 접미사를 지정 하는 데 필요한 링크 생성 `Async` 다음은 그 예입니다.

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

ASP.NET Core 3.0:

* 이전 작업은 *제품/목록* 경로에서 액세스할 수 있습니다.
* 링크 생성에는 접미사를 지정할 필요가 없습니다 `Async` . 다음은 그 예입니다.

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

이 변경 내용은 특성을 사용 하 여 지정 된 이름에는 영향을 주지 않습니다 [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . 에서 다음 코드를 사용 하 여 기본 동작을 사용 하지 않도록 설정할 수 있습니다 `Startup.ConfigureServices` .

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>링크 생성에 대 한 변경 내용

[이전 라우팅 버전의 차이점](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)에 대 한 설명서에 설명 된 것 처럼 링크 생성에는 몇 가지 차이점이 있습니다 ( `Url.Link` 예: 및 유사한 api 사용). 여기에는 다음이 포함됩니다.

* 기본적으로 끝점 라우팅을 사용 하는 경우 생성 된 Uri에서 경로 매개 변수의 대/소문자가 유지 되지 않을 수 있습니다. 이 동작은 인터페이스를 사용 하 여 제어할 수 있습니다 `IOutboundParameterTransformer` .
* 잘못 된 경로 (존재 하지 않는 컨트롤러/작업 또는 페이지)에 대 한 URI를 생성 하면 잘못 된 URI를 생성 하는 대신 끝점 라우팅 아래에 빈 문자열이 생성 됩니다.
* 앰비언트 값 (현재 컨텍스트의 경로 매개 변수)은 끝점 라우팅을 사용한 링크 생성에서 자동으로 사용 되지 않습니다. 이전에는 다른 작업 (또는 페이지)에 대 한 링크를 생성할 때 지정 되지 않은 경로 값이 *현재* 경로 앰비언트 값에서 유추 됩니다. 끝점 라우팅을 사용 하는 경우 링크 생성 중에 모든 경로 매개 변수를 명시적으로 지정 해야 합니다.

### <a name="razor-pages"></a>Razor Pages

Razor이제 매핑 페이지가 내에서 발생 `UseEndpoints` 합니다.

`MapRazorPages`앱이 페이지를 사용 하는 경우를 추가 Razor 합니다. 끝점 라우팅은 많은 프레임 워크에 대 한 지원을 포함 하므로 Razor 이제 페이지 추가는 옵트인 (opt in) 됩니다.

다음 방법에서는 `Startup.Configure` `MapRazorPages` 페이지에 대 한 지원을 추가 합니다 Razor .

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>끝점 라우팅 없이 MVC 사용

`UseMvc`ASP.NET Core 3.0에서 또는를 통해 MVC를 사용 `UseMvcWithDefaultRoute` 하려면 내에서 명시적인 옵트인이 필요 `Startup.ConfigureServices` 합니다. MVC는 초기화 하는 동안 권한 부여 및 CORS 미들웨어에 의존할 수 있는지 여부를 알아야 하므로이 작업을 수행 해야 합니다. 앱에서 지원 되지 않는 구성을 사용 하려고 하면 경고를 표시 하는 분석기가 제공 됩니다.

앱에 레거시 지원이 필요한 경우 `IRouter` `EnableEndpointRouting` 에서 다음 방법 중 하나를 사용 하지 않도록 설정 합니다 `Startup.ConfigureServices` .

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>상태 확인

상태 검사는 끝점 라우팅을 사용 하는 *라우터-웨어* 로 사용할 수 있습니다.

`MapHealthChecks`끝점 라우팅을 사용 하 여 상태 검사를 사용 하려면를 추가 합니다. `MapHealthChecks`메서드는와 유사한 인수를 허용 `UseHealthChecks` 합니다. Over를 사용 하는 이점은 `MapHealthChecks` `UseHealthChecks` 권한 부여를 적용 하 고 일치 정책에 대 한 보다 세분화 된 제어를 제공 하는 기능입니다.

다음 예제에서는에서 `MapHealthChecks` 상태 검사 끝점에 대해를 호출 합니다 `/healthz` .

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

<a name="hostb"></a>

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder가 WebHostBuilder를 대체 합니다.

ASP.NET Core 3.0 템플릿은 [제네릭 호스트](xref:fundamentals/host/generic-host)를 사용 합니다. 이전 버전은 [웹 호스트](xref:fundamentals/host/web-host)를 사용 했습니다. 다음 코드에서는 ASP.NET Core 3.0 템플릿이 생성 된 클래스를 보여 줍니다 `Program` .

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

다음 코드는 ASP.NET Core 2.2 템플릿에서 생성 된 클래스를 보여 줍니다 `Program` .

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>는 3.0에 유지 되며 `webBuilder` 앞의 코드 샘플에서 볼 수 있는의 형식입니다. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>이후 릴리스에서는 더 이상 사용 되지 않으며로 대체 됩니다 `HostBuilder` .

에서로의 가장 중요 한 변경 내용은 `WebHostBuilder` `HostBuilder` [DI (종속성 주입)](xref:fundamentals/dependency-injection)에 있습니다. 를 사용 하 `HostBuilder` 는 경우 다음을의 생성자에만 삽입할 수 있습니다 `Startup` .

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

`HostBuilder`DI 제약 조건:

* DI 컨테이너를 한 번만 작성 하도록 설정 합니다.
* 단일 항목의 여러 인스턴스를 확인 하는 것과 같은 결과 개체 수명 문제를 방지 합니다.

자세한 내용은 [ASP.NET Core 3에서 시작 서비스 주입 방지](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/)를 참조 하세요.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization이 다른 어셈블리로 이동 됨

AspNetCore의 ASP.NET Core 2.2 및 하위 `AddAuthorization` 메서드 *Microsoft.AspNetCore.Authorization.dll*는 다음과 같습니다.

* 이름이 변경 되었습니다 `AddAuthorizationCore` .
* *AspNetCore*로 이동 되었습니다 .입니다.

*AspNetCore* 및 *AspNetCore* 를 모두 사용 하는 앱은 영향을 받지 않습니다.

*AspNetCore* 를 사용 하지 않는 앱은 다음 중 하나를 수행 해야 합니다.

* *AspNetCore*에 대 한 참조를 추가 합니다. 이 접근 방식은 대부분의 앱에서 작동 하므로 모두 필요 합니다.
* 사용으로 전환`AddAuthorizationCore`

자세한 내용은 [ `AddAuthorization(o =>` 다른 어셈블리 #386에 있는 오버 로드의 주요 변경 내용](https://github.com/aspnet/Announcements/issues/386)을 참조 하세요.

## <a name="identity-ui"></a>Identity UI

IdentityASP.NET Core 3.0에 대 한 UI 업데이트:

* AspNetCore에 패키지 참조를 추가 합니다. [ Identity UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* 페이지를 사용 하지 않는 앱 Razor 은 `MapRazorPages` 를 호출 해야 합니다. 이 문서의 [ Razor 페이지](#razor-pages) 를 참조 하세요.
* 부트스트랩 4는 기본 UI 프레임 워크입니다. 기본값을 `IdentityUIFrameworkVersion` 변경 하려면 프로젝트 속성을 설정 합니다. 자세한 내용은 [이 GitHub 공지](https://github.com/aspnet/Announcements/issues/380)를 참조 하세요.

## SignalR

SignalRJavaScript 클라이언트가에서로 변경 되었습니다 `@aspnet/signalr` `@microsoft/signalr` . 이 변경 내용에 반응 하려면 *package. json* 파일, `require` 문 및 ECMAScript 문에서 참조를 변경 합니다 `import` .

### <a name="systemtextjson-is-the-default-protocol"></a>System.object는 기본 프로토콜입니다.

`System.Text.Json`는 이제 클라이언트와 서버 모두에서 사용 되는 기본 허브 프로토콜입니다.

에서를 `Startup.ConfigureServices` 호출 `AddJsonProtocol` 하 여 serializer 옵션을 설정 합니다.

**서버인**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**클라이언트로**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Newtonsoft.json로 전환 합니다.

[Newtonsoft.json에서 지원 되지 않는 기능](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)을 사용 하는 경우를 다시로 전환할 수 있습니다 `Newtonsoft.Json` . 이 문서 앞부분의 [ASP.NET Core 3.0 SignalR 프로젝트에서 newtonsoft.json 사용을](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) 참조 하세요.

## <a name="redis-distributed-caches"></a>Redis 분산 캐시

[Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) 패키지는 ASP.NET Core 3.0 이상 앱에 사용할 수 없습니다. 패키지 참조를 [StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis)로 바꿉니다. 자세한 내용은 <xref:performance/caching/distributed>를 참조하세요.

## <a name="opt-in-to-runtime-compilation"></a>런타임 컴파일 옵트인 (Opt in)

ASP.NET Core 3.0 이전에는 뷰의 런타임 컴파일이 프레임 워크의 암시적 기능 이었습니다. 런타임 컴파일을 통해 뷰의 빌드 시간 컴파일을 보완 합니다. Razor전체 앱을 다시 빌드하지 않고도 파일이 수정 될 때 프레임 워크에서 뷰와 페이지 (*cshtml* 파일)를 컴파일할 수 있습니다. 이 기능은 IDE에서 빠른 편집을 수행 하 고 브라우저를 새로 고쳐 변경 내용을 확인 하는 시나리오를 지원 합니다.

ASP.NET Core 3.0에서 런타임 컴파일은 옵트인 시나리오입니다. 빌드 시간 컴파일은 기본적으로 사용 하도록 설정 된 보기 컴파일의 유일한 메커니즘입니다. 런타임은 파일의 변경 내용을 검색할 때 프로젝트를 다시 빌드하기 위해 Visual Studio 또는 [dotnet watch를 사용](xref:tutorials/dotnet-watch) 하 여 *Visual Studio Code 합니다.* Visual Studio에서 실행 되는 프로젝트의 *.cs*, *cshtml*또는 *Razor* 파일 (<kbd>Ctrl + f5</kbd>)에 대 한 변경 내용이 있지만 디버깅 되지 않습니다 (<kbd>F5</kbd>). 프로젝트의 재컴파일을 트리거합니다.

ASP.NET Core 3.0 프로젝트에서 런타임 컴파일을 사용 하도록 설정 하려면

1. AspNetCore를 설치 합니다. [ Razor RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) NuGet 패키지입니다.
1. `Startup.ConfigureServices`다음을 호출 하도록 업데이트 `AddRazorRuntimeCompilation` :

    ASP.NET Core MVC의 경우 다음 코드를 사용 합니다.

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    ASP.NET Core 페이지의 경우 Razor 다음 코드를 사용 합니다.
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
의 샘플에서는 https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation 개발 환경에서 조건부로 런타임 컴파일을 사용 하도록 설정 하는 예제를 보여 줍니다.

파일 컴파일에 대 한 자세한 내용은 Razor 을 참조 하십시오 <xref:mvc/views/view-compilation> .

## <a name="migrate-libraries-via-multi-targeting"></a>다중 대상을 통해 라이브러리 마이그레이션

라이브러리는 여러 버전의 ASP.NET Core을 지원 해야 하는 경우가 많습니다. 이전 버전의 ASP.NET Core에 대해 컴파일된 대부분의 라이브러리는 문제 없이 계속 작동 해야 합니다. 다음 조건에서는 앱을 교차 컴파일해야 합니다.

* 라이브러리는 이진이 [변경](#breaking-api-changes)된 기능을 사용 합니다.
* 라이브러리는 ASP.NET Core 3.0의 새로운 기능을 활용 하려고 합니다. 

다음은 그 예입니다.

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

`#ifdefs`ASP.NET Core 3.0 관련 api를 사용 하도록 설정 하는 데 사용 합니다.

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

클래스 라이브러리에서 ASP.NET Core Api를 사용 하는 방법에 대 한 자세한 내용은을 참조 하십시오 <xref:fundamentals/target-aspnetcore> .

## <a name="miscellaneous-changes"></a>기타 변경 내용

.NET Core 3.0 이상의 유효성 검사 시스템은 Null을 허용하지 않는 매개 변수 또는 바인딩된 속성을 `[Required]` 특성을 포함한 것처럼 처리합니다. 자세한 내용은 [[Required] 특성](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute)을 참조 하세요.

### <a name="publish"></a>게시

프로젝트 디렉터리에서 *bin* 및 *obj* 폴더를 삭제 합니다.

## <a name="testserver"></a>TestServer

<xref:Microsoft.AspNetCore.TestHost.TestServer> [일반 호스트](xref:fundamentals/host/web-host)와 직접를 사용 하는 앱의 경우의에서를 만듭니다 `TestServer` <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A> .

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>API 변경 내용 중단

주요 변경 내용 검토:

* [ASP.NET Core 3.0 릴리스의 전체 주요 변경 내용 목록](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [위조 방지, CORS, 진단, MVC 및 라우팅을 방지 하기 위해 API 변경을 중단](https://github.com/aspnet/Announcements/issues/387)합니다. 이 목록에는 호환성 스위치에 대한 주요 변경 내용이 포함되어 있습니다.
* .NET Core, ASP.NET Core 및 Entity Framework Core 전체에서 2.2-3.0의 주요 변경 내용에 대 한 요약은 [버전 2.2에서 3.0로 마이그레이션에 대 한 주요 변경 내용](/dotnet/core/compatibility/2.2-3.0)을 참조 하세요.

## <a name="endpoint-routing-with-catch-all-parameter"></a>모든 매개 변수를 사용 하 여 끝점 라우팅

[!INCLUDE[](~/includes/catchall.md)]

## <a name="net-core-30-on-azure-app-service"></a>Azure App Service의 .NET Core 3.0

Azure App Service에 대 한 .NET Core 출시가 완료 되었습니다. .NET Core 3.0은 모든 Azure App Service 데이터 센터에서 사용할 수 있습니다.
