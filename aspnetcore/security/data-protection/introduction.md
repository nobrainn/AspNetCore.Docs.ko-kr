---
title: ASP.NET Core 데이터 보호
author: rick-anderson
description: 데이터 보호의 개념과 ASP.NET Core 데이터 보호 Api의 디자인 원리에 대해 알아봅니다.
ms.author: riande
ms.custom: mvc
ms.date: 10/24/2018
no-loc:
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/introduction
ms.openlocfilehash: b29711e8e1ef1558731ba58ca2ff14000af19ca2
ms.sourcegitcommit: 497be502426e9d90bb7d0401b1b9f74b6a384682
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/08/2020
ms.locfileid: "88019358"
---
# <a name="aspnet-core-data-protection"></a><span data-ttu-id="ed7bd-103">ASP.NET Core 데이터 보호</span><span class="sxs-lookup"><span data-stu-id="ed7bd-103">ASP.NET Core Data Protection</span></span>

<span data-ttu-id="ed7bd-104">웹 응용 프로그램은 보안에 중요 한 데이터를 저장 해야 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-104">Web applications often need to store security-sensitive data.</span></span> <span data-ttu-id="ed7bd-105">Windows에서는 데스크톱 응용 프로그램에 대해 DPAPI를 제공 하지만 웹 응용 프로그램에는 적합 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-105">Windows provides DPAPI for desktop applications but this is unsuitable for web applications.</span></span> <span data-ttu-id="ed7bd-106">ASP.NET Core 데이터 보호 스택은 개발자가 키 관리 및 순환을 포함 하 여 데이터를 보호 하는 데 사용할 수 있는 간단 하 고 사용 하기 쉬운 암호화 API를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-106">The ASP.NET Core data protection stack provide a simple, easy to use cryptographic API a developer can use to protect data, including key management and rotation.</span></span>

<span data-ttu-id="ed7bd-107">ASP.NET Core data protection stack은 ASP.NET 1.x-4.x. &lt; x에서 machineKey 요소에 대 한 장기 대체 역할을 하도록 디자인 되었습니다. &gt;</span><span class="sxs-lookup"><span data-stu-id="ed7bd-107">The ASP.NET Core data protection stack is designed to serve as the long-term replacement for the &lt;machineKey&gt; element in ASP.NET 1.x - 4.x.</span></span> <span data-ttu-id="ed7bd-108">최신 응용 프로그램에서 발생할 수 있는 대부분의 사용 사례에 대 한 기본 제공 솔루션을 제공 하는 동시에 이전 암호화 스택의 많은 단점을 해결 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-108">It was designed to address many of the shortcomings of the old cryptographic stack while providing an out-of-the-box solution for the majority of use cases modern applications are likely to encounter.</span></span>

## <a name="problem-statement"></a><span data-ttu-id="ed7bd-109">문제 설명</span><span class="sxs-lookup"><span data-stu-id="ed7bd-109">Problem statement</span></span>

<span data-ttu-id="ed7bd-110">전체 문제 설명은 한 문장으로 간략하게 될 수 있습니다. 나중에 검색할 수 있도록 신뢰할 수 있는 정보를 유지 해야 하지만 지 속성 메커니즘은 신뢰 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-110">The overall problem statement can be succinctly stated in a single sentence: I need to persist trusted information for later retrieval, but I don't trust the persistence mechanism.</span></span> <span data-ttu-id="ed7bd-111">웹 용어로는 "신뢰할 수 없는 클라이언트를 통해 라운드트립 된 신뢰할 수 있는 상태 여야 합니다."로 작성 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-111">In web terms, this might be written as "I need to round-trip trusted state via an untrusted client."</span></span>

<span data-ttu-id="ed7bd-112">이에 대 한 정식 예는 인증 cookie 또는 전달자 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-112">The canonical example of this is an authentication cookie or bearer token.</span></span> <span data-ttu-id="ed7bd-113">서버는 "I am Groot 및 xyz 권한 보유" 토큰을 생성 하 고 클라이언트에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-113">The server generates an "I am Groot and have xyz permissions" token and hands it to the client.</span></span> <span data-ttu-id="ed7bd-114">이후에 클라이언트는 해당 토큰을 서버에 다시 제공 하지만 서버는 클라이언트가 토큰을 위조 하지 못했음을 나타내는 일종의 보증을 요구 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-114">At some future date the client will present that token back to the server, but the server needs some kind of assurance that the client hasn't forged the token.</span></span> <span data-ttu-id="ed7bd-115">따라서 첫 번째 요구 사항: 신뢰성 (</span><span class="sxs-lookup"><span data-stu-id="ed7bd-115">Thus the first requirement: authenticity (a.k.a.</span></span> <span data-ttu-id="ed7bd-116">무결성, 변조 방지).</span><span class="sxs-lookup"><span data-stu-id="ed7bd-116">integrity, tamper-proofing).</span></span>

<span data-ttu-id="ed7bd-117">서버에서 지속형 상태를 신뢰 하므로이 상태에는 운영 환경과 관련 된 정보가 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-117">Since the persisted state is trusted by the server, we anticipate that this state might contain information that's specific to the operating environment.</span></span> <span data-ttu-id="ed7bd-118">이는 파일 경로, 사용 권한, 핸들 또는 다른 간접 참조의 형식 이거나 서버 관련 데이터의 다른 부분에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-118">This could be in the form of a file path, a permission, a handle or other indirect reference, or some other piece of server-specific data.</span></span> <span data-ttu-id="ed7bd-119">이러한 정보는 일반적으로 신뢰할 수 없는 클라이언트에 공개 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-119">Such information should generally not be disclosed to an untrusted client.</span></span> <span data-ttu-id="ed7bd-120">따라서 두 번째 요구 사항은 기밀입니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-120">Thus the second requirement: confidentiality.</span></span>

<span data-ttu-id="ed7bd-121">마지막으로, 최신 응용 프로그램은 구성 요소화 되었으므로 개별 구성 요소가 시스템의 다른 구성 요소와 상관 없이이 시스템을 활용 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-121">Finally, since modern applications are componentized, what we've seen is that individual components will want to take advantage of this system without regard to other components in the system.</span></span> <span data-ttu-id="ed7bd-122">예를 들어 전달자 토큰 구성 요소가이 스택을 사용 하는 경우 동일한 스택을 사용할 수도 있는 CSRF 메커니즘의 간섭 없이 작동 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-122">For instance, if a bearer token component is using this stack, it should operate without interference from an anti-CSRF mechanism that might also be using the same stack.</span></span> <span data-ttu-id="ed7bd-123">따라서 최종 요구 사항은 격리입니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-123">Thus the final requirement: isolation.</span></span>

<span data-ttu-id="ed7bd-124">요구 사항의 범위를 좁히기 위해 추가 제약 조건을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-124">We can provide further constraints in order to narrow the scope of our requirements.</span></span> <span data-ttu-id="ed7bd-125">Cryptosystem 내에서 작동 하는 모든 서비스는 동일한 신뢰를 받고 직접 제어 하는 서비스 외부에서 데이터를 생성 하거나 사용할 필요가 없는 것으로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-125">We assume that all services operating within the cryptosystem are equally trusted and that the data doesn't need to be generated or consumed outside of the services under our direct control.</span></span> <span data-ttu-id="ed7bd-126">또한 웹 서비스에 대 한 각 요청이 cryptosystem을 한 번 이상 통과할 수 있으므로 작업이 최대한 빠르게 수행 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-126">Furthermore, we require that operations are as fast as possible since each request to the web service might go through the cryptosystem one or more times.</span></span> <span data-ttu-id="ed7bd-127">이를 통해 시나리오에 적합 한 대칭 암호화를 사용할 수 있으며, 필요할 때까지 비대칭 암호화의 할인율을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-127">This makes symmetric cryptography ideal for our scenario, and we can discount asymmetric cryptography until such a time that it's needed.</span></span>

## <a name="design-philosophy"></a><span data-ttu-id="ed7bd-128">디자인 원칙</span><span class="sxs-lookup"><span data-stu-id="ed7bd-128">Design philosophy</span></span>

<span data-ttu-id="ed7bd-129">기존 스택의 문제를 식별 하 여 시작 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-129">We started by identifying problems with the existing stack.</span></span> <span data-ttu-id="ed7bd-130">이 작업이 완료 되 면 기존 솔루션의 가로를 조사 하 고 기존 솔루션이 아직 검색 한 기능을가지고 있지 않음을 결론 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-130">Once we had that, we surveyed the landscape of existing solutions and concluded that no existing solution quite had the capabilities we sought.</span></span> <span data-ttu-id="ed7bd-131">그런 다음 몇 가지 안내 원칙에 따라 솔루션을 설계 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-131">We then engineered a solution based on several guiding principles.</span></span>

* <span data-ttu-id="ed7bd-132">시스템은 구성을 간단 하 게 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-132">The system should offer simplicity of configuration.</span></span> <span data-ttu-id="ed7bd-133">시스템이 구성 되지 않은 것이 가장 이상적입니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-133">Ideally the system would be zero-configuration and developers could hit the ground running.</span></span> <span data-ttu-id="ed7bd-134">개발자가 특정 측면 (예: 키 리포지토리)을 구성 해야 하는 경우 이러한 특정 구성을 간단 하 게 하기 위해 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-134">In situations where developers need to configure a specific aspect (such as the key repository), consideration should be given to making those specific configurations simple.</span></span>

* <span data-ttu-id="ed7bd-135">간단한 소비자 지향 API를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-135">Offer a simple consumer-facing API.</span></span> <span data-ttu-id="ed7bd-136">Api는 올바르게 사용 하기 쉽고 잘못 사용 하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-136">The APIs should be easy to use correctly and difficult to use incorrectly.</span></span>

* <span data-ttu-id="ed7bd-137">개발자는 키 관리 원칙을 배울 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-137">Developers shouldn't learn key management principles.</span></span> <span data-ttu-id="ed7bd-138">시스템은 개발자를 대신해 알고리즘 선택 및 키 수명을 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-138">The system should handle algorithm selection and key lifetime on the developer's behalf.</span></span> <span data-ttu-id="ed7bd-139">개발자는 원시 키 자료에 대 한 액세스 권한이 없어도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-139">Ideally the developer should never even have access to the raw key material.</span></span>

* <span data-ttu-id="ed7bd-140">가능 하면 휴지 상태의 키를 보호 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-140">Keys should be protected at rest when possible.</span></span> <span data-ttu-id="ed7bd-141">시스템은 적절 한 기본 보호 메커니즘을 파악 하 고 자동으로 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-141">The system should figure out an appropriate default protection mechanism and apply it automatically.</span></span>

<span data-ttu-id="ed7bd-142">이러한 원칙을 염두에 두면 간단 하 고 [사용 하기 쉬운](xref:security/data-protection/using-data-protection) 데이터 보호 스택을 개발 했습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-142">With these principles in mind we developed a simple, [easy to use](xref:security/data-protection/using-data-protection) data protection stack.</span></span>

<span data-ttu-id="ed7bd-143">ASP.NET Core 데이터 보호 Api는 주로 기밀 페이로드의 무한 지 속성에 적합 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-143">The ASP.NET Core data protection APIs are not primarily intended for indefinite persistence of confidential payloads.</span></span> <span data-ttu-id="ed7bd-144">[WINDOWS CNG DPAPI](/windows/win32/seccng/cng-dpapi) 및 [Azure Rights Management](/rights-management/) 와 같은 기타 기술은 무한 저장소의 시나리오에 보다 적합 하며 강력한 키 관리 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-144">Other technologies like [Windows CNG DPAPI](/windows/win32/seccng/cng-dpapi) and [Azure Rights Management](/rights-management/) are more suited to the scenario of indefinite storage, and they have correspondingly strong key management capabilities.</span></span> <span data-ttu-id="ed7bd-145">즉, 기밀 데이터의 장기 보호를 위해 개발자가 ASP.NET Core 데이터 보호 Api를 사용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-145">That said, there's nothing prohibiting a developer from using the ASP.NET Core data protection APIs for long-term protection of confidential data.</span></span>

## <a name="audience"></a><span data-ttu-id="ed7bd-146">사용자</span><span class="sxs-lookup"><span data-stu-id="ed7bd-146">Audience</span></span>

<span data-ttu-id="ed7bd-147">데이터 보호 시스템은 5 개의 주 패키지로 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-147">The data protection system is divided into five main packages.</span></span> <span data-ttu-id="ed7bd-148">이러한 Api의 다양 한 측면은 세 가지 주요 대상을 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-148">Various aspects of these APIs target three main audiences;</span></span>

1. <span data-ttu-id="ed7bd-149">[소비자 Api 개요](xref:security/data-protection/consumer-apis/overview) 는 응용 프로그램 및 프레임 워크 개발자를 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-149">The [Consumer APIs Overview](xref:security/data-protection/consumer-apis/overview) target application and framework developers.</span></span>

   <span data-ttu-id="ed7bd-150">"스택 작동 방법 또는 구성 방법에 대해 알아보는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-150">"I don't want to learn about how the stack operates or about how it's configured.</span></span> <span data-ttu-id="ed7bd-151">단순히 Api를 성공적으로 사용 하는 확률이 매우 높은 간단한 방법으로에서 일부 작업을 수행 하려고 합니다. "</span><span class="sxs-lookup"><span data-stu-id="ed7bd-151">I simply want to perform some operation in as simple a manner as possible with high probability of using the APIs successfully."</span></span>

2. <span data-ttu-id="ed7bd-152">[구성 api](xref:security/data-protection/configuration/overview) 는 응용 프로그램 개발자 및 시스템 관리자를 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-152">The [configuration APIs](xref:security/data-protection/configuration/overview) target application developers and system administrators.</span></span>

   <span data-ttu-id="ed7bd-153">"데이터 보호 시스템에 기본 경로 또는 설정이 필요 하지 않습니다." 라는 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-153">"I need to tell the data protection system that my environment requires non-default paths or settings."</span></span>

3. <span data-ttu-id="ed7bd-154">확장성 Api는 개발자가 사용자 지정 정책을 구현 하는 것을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-154">The extensibility APIs target developers in charge of implementing custom policy.</span></span> <span data-ttu-id="ed7bd-155">이러한 Api를 사용 하는 것은 드문 상황 및 숙련 된 보안 개발자로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-155">Usage of these APIs would be limited to rare situations and experienced, security aware developers.</span></span>

   <span data-ttu-id="ed7bd-156">"시스템 내에서 전체 구성 요소를 교체 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-156">"I need to replace an entire component within the system because I have truly unique behavioral requirements.</span></span> <span data-ttu-id="ed7bd-157">내 요구 사항을 충족 하는 플러그 인을 빌드하기 위해 API 표면의 일반적으로 사용 되지 않는 부분을 배워야 합니다. "</span><span class="sxs-lookup"><span data-stu-id="ed7bd-157">I am willing to learn uncommonly-used parts of the API surface in order to build a plugin that fulfills my requirements."</span></span>

## <a name="package-layout"></a><span data-ttu-id="ed7bd-158">패키지 레이아웃</span><span class="sxs-lookup"><span data-stu-id="ed7bd-158">Package layout</span></span>

<span data-ttu-id="ed7bd-159">데이터 보호 스택은 5 개의 패키지로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-159">The data protection stack consists of five packages.</span></span>

* <span data-ttu-id="ed7bd-160">[AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/) 는 <xref:Microsoft.AspNetCore.DataProtection.IDataProtectionProvider> <xref:Microsoft.AspNetCore.DataProtection.IDataProtector> 데이터 보호 서비스를 만들기 위한 및 인터페이스를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-160">[Microsoft.AspNetCore.DataProtection.Abstractions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/) contains the <xref:Microsoft.AspNetCore.DataProtection.IDataProtectionProvider> and <xref:Microsoft.AspNetCore.DataProtection.IDataProtector> interfaces to create data protection services.</span></span> <span data-ttu-id="ed7bd-161">또한 이러한 형식 (예: [IDataProtector](xref:Microsoft.AspNetCore.DataProtection.DataProtectionCommonExtensions.Protect*))으로 작업 하는 데 유용한 확장 메서드가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-161">It also contains useful extension methods for working with these types (for example, [IDataProtector.Protect](xref:Microsoft.AspNetCore.DataProtection.DataProtectionCommonExtensions.Protect*)).</span></span> <span data-ttu-id="ed7bd-162">데이터 보호 시스템이 다른 곳에서 인스턴스화되고 API를 사용 하는 경우 참조 `Microsoft.AspNetCore.DataProtection.Abstractions` 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-162">If the data protection system is instantiated elsewhere and you're consuming the API, reference `Microsoft.AspNetCore.DataProtection.Abstractions`.</span></span>

* <span data-ttu-id="ed7bd-163">[AspNetCore 보호](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection/) 는 핵심 암호화 작업, 키 관리, 구성 및 확장성을 포함 하 여 데이터 보호 시스템의 핵심 구현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-163">[Microsoft.AspNetCore.DataProtection](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection/) contains the core implementation of the data protection system, including core cryptographic operations, key management, configuration, and extensibility.</span></span> <span data-ttu-id="ed7bd-164">데이터 보호 시스템을 (예:에 추가 <xref:Microsoft.Extensions.DependencyInjection.IServiceCollection> ) 인스턴스화하거나 해당 동작을 수정 하거나 확장 하려면를 참조 `Microsoft.AspNetCore.DataProtection` 합니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-164">To instantiate the data protection system (for example, adding it to an <xref:Microsoft.Extensions.DependencyInjection.IServiceCollection>) or modifying or extending its behavior, reference `Microsoft.AspNetCore.DataProtection`.</span></span>

* <span data-ttu-id="ed7bd-165">[AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/) 에는 개발자가 유용 하지만 핵심 패키지에 속하지 않는 추가 api가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-165">[Microsoft.AspNetCore.DataProtection.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/) contains additional APIs which developers might find useful but which don't belong in the core package.</span></span> <span data-ttu-id="ed7bd-166">예를 들어이 패키지에는 데이터 보호 시스템을 인스턴스화하여 종속성 주입 없이 파일 시스템의 위치에 키를 저장 하는 팩터리 메서드가 포함 되어 있습니다 (참조 <xref:Microsoft.AspNetCore.DataProtection.DataProtectionProvider> ).</span><span class="sxs-lookup"><span data-stu-id="ed7bd-166">For instance, this package contains factory methods to instantiate the data protection system to store keys at a location on the file system without dependency injection (see <xref:Microsoft.AspNetCore.DataProtection.DataProtectionProvider>).</span></span> <span data-ttu-id="ed7bd-167">또한 보호 된 페이로드의 수명을 제한 하는 확장 메서드도 포함 되어 있습니다 (참조 <xref:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector> ).</span><span class="sxs-lookup"><span data-stu-id="ed7bd-167">It also contains extension methods for limiting the lifetime of protected payloads (see <xref:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector>).</span></span>

* <span data-ttu-id="ed7bd-168">[Microsoft.AspNetCore.DataProtection.SystemWeb](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.SystemWeb/) 를 기존 ASP.NET 4.x 앱에 설치 하 여 `<machineKey>` 새 ASP.NET Core 데이터 보호 스택을 사용 하도록 작업을 리디렉션할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-168">[Microsoft.AspNetCore.DataProtection.SystemWeb](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.SystemWeb/) can be installed into an existing ASP.NET 4.x app to redirect its `<machineKey>` operations to use the new ASP.NET Core data protection stack.</span></span> <span data-ttu-id="ed7bd-169">자세한 내용은 <xref:security/data-protection/compatibility/replacing-machinekey>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-169">For more information, see <xref:security/data-protection/compatibility/replacing-machinekey>.</span></span>

* <span data-ttu-id="ed7bd-170">[AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Cryptography.KeyDerivation/) 는 PBKDF2 암호 해시 루틴의 구현을 제공 하며, 사용자 암호를 안전 하 게 처리 해야 하는 시스템에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-170">[Microsoft.AspNetCore.Cryptography.KeyDerivation](https://www.nuget.org/packages/Microsoft.AspNetCore.Cryptography.KeyDerivation/) provides an implementation of the PBKDF2 password hashing routine and can be used by systems that must handle user passwords securely.</span></span> <span data-ttu-id="ed7bd-171">자세한 내용은 <xref:security/data-protection/consumer-apis/password-hashing>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ed7bd-171">For more information, see <xref:security/data-protection/consumer-apis/password-hashing>.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="ed7bd-172">추가 자료</span><span class="sxs-lookup"><span data-stu-id="ed7bd-172">Additional resources</span></span>

<xref:host-and-deploy/web-farm>
